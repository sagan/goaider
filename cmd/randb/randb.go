package randb

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"os"
	"strings"

	"github.com/natefinch/atomic"
	"github.com/sagan/goaider/cmd"
	"github.com/sagan/goaider/util"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

var randCmd = &cobra.Command{
	Use:     "randb",
	Aliases: []string{"randombytes"},
	Short:   "Get a cryptographically secure random bytes of length 16. Output base64 by default",
	Long: `Get a cryptographically secure random bytes of length 16. Output base64 by default.

It outputs to stdout.`,
	RunE: doRandb,
}

var (
	flagForce  bool
	flagHex    bool // output hex string
	flagRaw    bool // output raw binary
	flagUrl    bool // output in URL-safe BASE64 (without padding) encoding instead of standard base64
	flagLength int  // length of generated bytes. default to 16.
	flagOutput string
)

func doRandb(cmd *cobra.Command, args []string) (err error) {
	if flagOutput != "-" {
		if exists, err := util.FileExists(flagOutput); err != nil || (exists && !flagForce) {
			return fmt.Errorf("output file %q exists or can't access, err=%w", flagOutput, err)
		}
	}
	if util.CountNonZeroVariables(flagHex, flagRaw, flagUrl) > 1 {
		return fmt.Errorf("only one of --hex, --raw, --url can be set")
	}
	if flagLength <= 0 {
		return fmt.Errorf("length must be greater than 0")
	}

	b := util.RandBytes(flagLength)
	s := ""
	if flagHex {
		s = fmt.Sprintf("%x", b)
	} else if flagUrl {
		s = fmt.Sprint(base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(b))
	} else if !flagRaw {
		s = fmt.Sprint(base64.StdEncoding.EncodeToString(b))
	}

	if flagOutput == "-" {
		if s != "" {
			_, err = cmd.OutOrStdout().Write([]byte(s))
		} else {
			if cmd.OutOrStdout() == os.Stdout && term.IsTerminal(int(os.Stdout.Fd())) {
				return fmt.Errorf("stdout is tty. use --raw only when redirecting to a file or piping to another command")
			}
			_, err = cmd.OutOrStdout().Write(b)
		}
	} else {
		if s != "" {
			err = atomic.WriteFile(flagOutput, strings.NewReader(s))
		} else {
			err = atomic.WriteFile(flagOutput, bytes.NewReader(b))
		}
	}
	if err != nil {
		return err
	}
	return nil
}

func init() {
	randCmd.Flags().BoolVarP(&flagHex, "hex", "x", false, "Output hex string")
	randCmd.Flags().BoolVarP(&flagRaw, "raw", "r", false, "Output raw binary")
	randCmd.Flags().BoolVarP(&flagUrl, "url", "u", false,
		"Output in URL-safe BASE64 (without padding) encoding instead of standard base64")
	randCmd.Flags().IntVarP(&flagLength, "length", "l", 16, "Length of the random bytes")
	randCmd.Flags().BoolVarP(&flagForce, "force", "", false, "Force overwriting without confirmation")
	randCmd.Flags().StringVarP(&flagOutput, "output", "o", "-", `Output file path. Use "-" for stdout`)
	cmd.RootCmd.AddCommand(randCmd)
}
